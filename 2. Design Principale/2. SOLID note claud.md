# SOLID Principles - Complete Guide

## S - Single Responsibility Principle (SRP)
**Definition:** A class should have only one reason to change, meaning it should have only one job or responsibility.

### ✅ Good Example:
```php
<?php
// Each class has a single responsibility
class Student {
    private $name;
    private $email;
    
    public function getName() { return $this->name; }
    public function setName($name) { this->name = $name; }
    public function getEmail() { return $this->email; }
}

class StudentRepository {
    public function save(Student $student) {
        // Handle database operations
    }
    public function delete($id) {
        // Handle deletion
    }
}

class NotificationService {
    public function sendEmail($email, $message) {
        // Handle email notifications
    }
}
?>
```

### ❌ Bad Example:
```php
<?php
class Student {
    private $name;
    private $email;
    
    public function getName() { return $this->name; }
    public function save() { /* database logic */ }
    public function sendEmail() { /* email logic */ }
    public function generateReport() { /* reporting logic */ }
    // ❌ Too many responsibilities in one class
}
?>
```

---

## O - Open/Closed Principle (OCP)
**Definition:** Software entities should be open for extension but closed for modification.

### ✅ Good Example:
```php
<?php
abstract class Shape {
    abstract public function calculateArea();
}

class Rectangle extends Shape {
    private $width, $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return $this->width * $this->height;
    }
}

class Circle extends Shape {
    private $radius;
    
    public function __construct($radius) {
        $this->radius = $radius;
    }
    
    public function calculateArea() {
        return pi() * $this->radius * $this->radius;
    }
}

class AreaCalculator {
    public function calculateTotalArea(array $shapes) {
        $total = 0;
        foreach($shapes as $shape) {
            $total += $shape->calculateArea(); // ✅ No modification needed for new shapes
        }
        return $total;
    }
}
?>
```

---

## L - Liskov Substitution Principle (LSP)
**Definition:** Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

### ✅ Good Example:
```php
<?php
interface Flyable {
    public function fly();
}

interface Walkable {
    public function walk();
}

class Sparrow implements Flyable, Walkable {
    public function fly() {
        echo "Sparrow is flying\n";
    }
    
    public function walk() {
        echo "Sparrow is walking\n";
    }
}

class Ostrich implements Walkable {
    public function walk() {
        echo "Ostrich is walking\n";
    }
}

function makeItFly(Flyable $bird) {
    $bird->fly();
}

makeItFly(new Sparrow()); // ✅ Works correctly
// makeItFly(new Ostrich()); // ❌ Won't compile - Ostrich doesn't implement Flyable
?>
```

### ❌ Bad Example:
```php
<?php
class Bird {
    public function fly() {
        echo "Bird is flying\n";
    }
}

class Ostrich extends Bird {
    public function fly() {
        throw new Exception("Ostriches can't fly!"); // ❌ Violates LSP
    }
}
?>
```

---

## I - Interface Segregation Principle (ISP)
**Definition:** A client should not be forced to implement interfaces it doesn't use. Create specific interfaces rather than one general-purpose interface.

### ✅ Good Example:
```php
<?php
interface Readable {
    public function read();
}

interface Writable {
    public function write($data);
}

interface Executable {
    public function execute();
}

// File only needs read/write
class TextFile implements Readable, Writable {
    public function read() {
        echo "Reading text file\n";
    }
    
    public function write($data) {
        echo "Writing to text file: $data\n";
    }
}

// Script needs all three
class ScriptFile implements Readable, Writable, Executable {
    public function read() {
        echo "Reading script file\n";
    }
    
    public function write($data) {
        echo "Writing to script file: $data\n";
    }
    
    public function execute() {
        echo "Executing script\n";
    }
}
?>
```

### ❌ Bad Example:
```php
<?php
interface FileInterface {
    public function read();
    public function write($data);
    public function execute(); // ❌ Not all files can execute
}

class TextFile implements FileInterface {
    public function read() { /* implementation */ }
    public function write($data) { /* implementation */ }
    public function execute() {
        throw new Exception("Text files can't execute"); // ❌ Forced to implement
    }
}
?>
```

---

## D - Dependency Inversion Principle (DIP)
**Definition:** High-level modules should not depend on low-level modules. Both should depend on abstractions (interfaces).

### ✅ Good Example:
```php
<?php
interface DatabaseInterface {
    public function save($data);
    public function find($id);
}

class MySQLDatabase implements DatabaseInterface {
    public function save($data) {
        echo "Saving to MySQL: $data\n";
    }
    
    public function find($id) {
        echo "Finding in MySQL: $id\n";
    }
}

class PostgreSQLDatabase implements DatabaseInterface {
    public function save($data) {
        echo "Saving to PostgreSQL: $data\n";
    }
    
    public function find($id) {
        echo "Finding in PostgreSQL: $id\n";
    }
}

class UserService {
    private $database;
    
    public function __construct(DatabaseInterface $database) {
        $this->database = $database; // ✅ Depends on abstraction
    }
    
    public function createUser($userData) {
        $this->database->save($userData);
    }
}

// Usage - easily switchable
$userService = new UserService(new MySQLDatabase());
// or
$userService = new UserService(new PostgreSQLDatabase());
?>
```

### ❌ Bad Example:
```php
<?php
class MySQLDatabase {
    public function save($data) {
        echo "Saving to MySQL: $data\n";
    }
}

class UserService {
    private $database;
    
    public function __construct() {
        $this->database = new MySQLDatabase(); // ❌ Tightly coupled
    }
    
    public function createUser($userData) {
        $this->database->save($userData);
    }
}
?>
```

---

## DRY Principle (Don't Repeat Yourself)
**Note:** While not part of SOLID, it's often mentioned together.

### ✅ Good Example:
```php
<?php
abstract class BaseProcessor {
    protected function validateData($data) {
        // Common validation logic
        return !empty($data);
    }
    
    protected function logOperation($operation) {
        echo "Logging: $operation\n";
    }
    
    abstract public function process($data);
}

class EmailProcessor extends BaseProcessor {
    public function process($data) {
        if ($this->validateData($data)) {
            $this->logOperation("Email processing");
            // Email-specific processing
        }
    }
}

class SMSProcessor extends BaseProcessor {
    public function process($data) {
        if ($this->validateData($data)) {
            $this->logOperation("SMS processing");
            // SMS-specific processing
        }
    }
}
?>
```

## Summary
- **S**RP: One class, one responsibility
- **O**CP: Open for extension, closed for modification
- **L**SP: Subtypes must be substitutable for their base types
- **I**SP: Many specific interfaces are better than one general interface
- **D**IP: Depend on abstractions, not concretions
